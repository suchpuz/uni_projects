
#include <ros/ros.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <actionlib/client/simple_action_client.h>
#include <iostream>
#include <tf/transform_broadcaster.h>
#include <fstream>
#include <string>
#include <ros/ros.h>
#include <ros/package.h>
using namespace std;
void navigation(double,double,double);
 
 string crea_path() { 
	    string path = ros::package::getPath("second_project");
	    const string endpath = "/waypoints.csv";
	    string line;
		path += endpath; 
        return path; 
    }




// Action specification for move_base
typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> MoveBaseClient;
 
int main(int argc, char** argv){

	string path = crea_path();
	string s;
	string elements_data;
	ifstream data_file(path, std::ios::in);
	bool end=false;
	ros::init(argc, argv, "navigation_node");
	while(ros::ok()){
		if (data_file.is_open()){
    		while (getline (data_file, s)){
				int pos1 = s.find(",");
    			string sub = s.substr(0,pos1);
    			int pos2 = s.find(",",pos1+1);
    			string sub2 = s.substr (pos1+1, pos2-(pos1+1));
    			int pos3 = s.find("\n",pos2+1);
    			string sub3 = s.substr(pos2+1, pos3-(pos2+1));
				//ROS_INFO_STREAM(sub<<sub2<<sub3<<endl);
				double posx = stod(sub);
				double posy = stod(sub2);
				double yaw = stod(sub3);
				//ROS_INFO_STREAM(posx << "  " << posy << "  " << yaw<<endl );
				navigation(posx,posy,yaw);
			}
		}
		else{
			std::cout<<"FILE NOT READ."<<endl;
			end=true;
		}
		data_file.close();
	}
 
	}
     
  void navigation(double x, double y, double yaw){
	MoveBaseClient ac("move_base", true);		//tell the action client that we want to spin a thread by default
  	while(!ac.waitForServer(ros::Duration(5.0))){  // Wait for the action server to come up so that we can begin processing goals.
    	ROS_INFO("Waiting for the move_base action server to come up");
	}
    // Create a new goal to send to move_base 
    move_base_msgs::MoveBaseGoal goal;
 
    // Send a goal to the robot
    goal.target_pose.header.frame_id = "map";
    goal.target_pose.header.stamp = ros::Time::now();
         
    bool valid_selection = true;
    goal.target_pose.pose.position.x = x;
    goal.target_pose.pose.position.y = y;
	geometry_msgs::Quaternion quat = tf::createQuaternionMsgFromYaw(yaw);
    goal.target_pose.pose.orientation = quat;
    
    ROS_INFO("Sending goal");
    ac.sendGoal(goal);
 
    // Wait until the robot reaches the goal
    ac.waitForResult();
 
    if(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
      ROS_INFO("The robot has arrived at the goal location");
    else
      ROS_INFO("The robot failed to reach the goal location for some reason");
	return;
  }
